# Django Tutorial Fundamentals
## Pre-Requisites
- Python (basics, classes, inheritence)
- Relational Databases (Tables, columns, keys, relationships)

# Sections
- Introduction to Django
- Fundamentals of web Development
- Setting up the development environment
- Your first Django project
- 2 essential debugging techniques

## Introduction to Django
- It is free and open-source web framework for building web apps with python.
- It helps build web apps with less code and less time.
- It has most feature inbuilt
    - It has admin interface
    - It has Object-relational mapper
    - It has authetication
    - It has caching

## Fundamentals of web development
- Websites have two parts: frontend and backend
- Frontend is loaded on web browser on client machine
- Backend is loaded on webserver and reponsible for business logic
- The address needed to visit the web site is URL
- It locates a resource on the internet which can be a web page, image, video or pdf
- The browser sends a request to web server when user enters a URL in browser address bar.
- This communication is defined by HTTP
- For each page access while navigation by user, the browser sends an http request and in turn recieves a response page back
- The requested page is generated by web server and sent to user as HTML document
- Other option for web server is to send the data requested and client generates HTML.
- This is the best practice as it allows the web browser to serve more users.
- Client side web page generating framework are:
    - React
    - Angular
    - Vue
- Server side tools for building backend
    - Django
    - ASP.NET CORE
    - EXPRESS
- When we assign the client side is resonsible for generating web page, the backend server basically acts as gateway to data.
- The backend provides the endpoints to retrived various types of data by the user. The API

## Setting up development environment
- Update python to latest version
- `pip3 install pipenv`
- `pipenv install Django`
- `pipenv shell` will launch subshell in virtual environment
- django-admin is a tool that comes with django and it creates a django project `django-admin startproject eCommerceApp .` in the current working directory.
- django-admin startproject will start the project straightaway so, we have to run `python manage.py runserver PORT_NUMBER, will attach PORT_NUMBER 8000 if not provided.

## Your First Django project
- Every django project is collection of certain apps that provide respective functionalities
- can check `settings.py` module
- `INSTALLED_APPS` list provides definition of various apps possible with django, for example - `django.contrib.admin` that controls admin, `django.contrib.auth` that covers authentication, `django.contrib.messages` is used for displaying one time messages to the user, `django.contrib.staticfiles` are used to host static web pages, images etc. in there.
- we can create our own app too, open a new terminal window and start the same pipenv environment ie. Django-code and write code `python3 manage.py startapp <app-name>`
- migration folder here is used to generate database table
- admin module defines how the admin module for this app will look like.
- apps module configures this app.
- model module is used to define model classes for the app to pull out data from database and present to the app.
- tests module contains the unittest for the app.
- view module is the request handler
- we have to register this app by add the name to the INSTALLED_APPS in settings.py

- view module is used in data exchange as http request-response.
- in views module you define the view function, the view function takes a request, optionally modify it and returns a response as a request handler
- simple response can be done with `return HttpResponse('string')` in this function.
- we can have a separate module `urls.py` for mapping urls to view functions.
- in the urls.py for playground we add urlconfiguration for every app
- in the urls.py for eCommerceApp we add the urlconfiguration for playground and other apps.
- template.py is used to hold views/template to return html content for the client, so in templates folder we create html file.
- Now for html file will need to respond with html markup to the client for which the normal HttpResponse need to be replaced with render function as return `render(request, <file.html>)`
- we can send additional arguments in the form of a dictionary as render function's third argument and it will be accessible with the key name in html file in templates mentioned in render function.
- *we should use django to build APIs that return data most of the time thus, templates are not used mostly unless it is the special cases*.
- We can debug django apps with vscode debugger or we can install django-debugger-toolbar which can be installed with pipenv in the python environment.
- To setup django-debug-toolbar after install we have to
    - add `debug_toolbar` to `INSTALLED_APPS`
    - add 'django.middleware.clickjacking.XFrameOptionsMiddleware' to `MIDDLEWARE`
    - add `INTERNAL_IPS = ['127.0.0.1',]` to settings.py
    
# models

# sections
- Introduction to data modeling
- Building an e-commerce data model
- Organizing models in apps
- Coding model classes

## Building an e-commerce data model
- Suppose we have two entities `Product` and `Cart` and `Cart` has an attribute `created_at` and they have many-to-many relationship.
- The relationship determines for a product which cart(s) it belongs to.
- To determine the quantity of a product, we can create an *association class* `CartItem` which will contain attribute `quantity`.
- It can also be represented by a by separate relationship between:
    - `Cart` and `CartItem` with one-to-many relationship. there can be many cartitem present in one cart.
    - `Product` and `CartItem` with one-to-many relationship. A product can be present in many cartItems.
- If we have entities like `Product`, `Customer`, `OrderItem` and `Order`
    - `Product` and `OrderItem` can have one-to-many relationship where one product can be available in many orderItem
    - `Customer` and `Order` can have one-to-many relationship where one customer can place many orders but any order can have only one customer
    - `Order` placed can have many `product` and `product` can be placed in many `order` so,
        - we can have `OrderItem` entity which has many-to-one relationship with `Order` ie. many order items can be present in one order but any orderitem can be present in one order.
        - we can have `OrderItem` entity which has many-to-one relationship with `Product` entity ie. a product can be present in many orderitems but an order item can be only one product.
- We can add all the functionality to a single app but it will lead to a single monolith which is difficult to understand, maintain and scale as the project complexity increases.
    - We can decouple the project into apps containing respective specific functionalities like `orders`, `cart`, `cartitem`, `product` but there is a lot of coupling in these apps as any change in any one of them will lead to breaking of other dependent apps.
- A good model design is the one with minimal coupling and high cohesion/high focus.
- For entity `Order` we can have attributes `placed_at` and `order_status` where, `order_status` can be set with datatypes as distinct choices `COMPLETED`, `PENDING` and `FAILED` as array of tuples in choices argument of charfield datatype.
```python
class Order(models.Model):
    STATUS_PENDING = 'P'
    STATUS_COMPLETE = 'C'
    STATUS_FAILED = 'F'

    ORDER_STATUS = [
        (STATUS_PENDING, 'P'),
        (STATUS_COMPLETE, 'C'),
        (STATUS_FAILED, 'F')
    ]

    placed_at = models.DateTimeField(auto_add_now=True)
    payment_status = models.CharField(max_length=1, choices=ORDER_STATUS, default=STATUS_PENDING)
```
- For entity `Address` we can have attributes `street`, `city` and `customer`. Here, we will need to implement one-to-one relationship between `Customer` and `Address` entities
    - For the above, we can set attributes `street`, `city` and `customer` with `OneToOneField`
    ```python
    class Address(models.Model):
        street = models.CharField(max_length=255)
        city = models.CharField(max_length=255)
        customer = models.OneToOneField(Customer, on_delete=models.CASCADE, primary_key=True) # models.DEFAULT, models.PROTECT, models.SET_NULL
    ```
    - we need to set `primary_key` attribute to `True` for `customer`, if not done, django will create a separate `id` field for each `Address` instance which will result in one-to-many relationship.

- If we needed to set one-to-many relationship between entities `Customer` and `Address` all we have to do is to remove the `primary_key` argument from Foriegn key.
    - We can add `on_delete` argument to `models.PROTECT` in order to prevernt accidental deletion of instances from entities on which multiple instance of other entity are related.

- For many-to-many relationship between `promotions` and `Products`, we need to set `ManyToManyField` field type for `promotions` field in `Product` entity.

## database setup
- MySQL, Postgres and SQLite are used most ofter for database needs with Django.
- 